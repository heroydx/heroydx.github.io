---
layout:     post
title:      70. Climbing Stairs
subtitle:   第一遍C & C++
date:       2018-03-14
author:     heroydx
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - C
    - C++
    - leetcode
---
# 题目分析

[题目](https://leetcode.com/problems/climbing-stairs/description/)上梯子问题，每次只能上1个或2个阶，求这个梯子有n个阶时的，一共有多少种上梯子的方法。

>Example 1:

>Input: 2

>Output:  2

>Explanation:  There are two ways to climb to the top.

>1. 1 step + 1 step

>2. 2 steps

>Example 2:

>Input: 3

>Output:  3

>Explanation:  There are three ways to climb to the top.

>1. 1 step + 1 step + 1 step

>2. 1 step + 2 steps

>3. 2 steps + 1 step

首先想到的就是迭代的方法去求，其次，通过观察上梯子的方法种数，可以联想到套用斐波那契数列进行计算。

# 编程实现

## C实现

### 方法一---斐波那契数列

>As distinct ways’ number of n stair s(n)=s(n-1)+s(n-2), in stair 0, there is only one way: start-> start, in stair 1, there also one way: start-> stair 1, move one step. set s(0)=s(1)=1, so s(2)=1+1=2;
The array is 1 1 2 3 5 8 13…

    //斐波那契数列的方法
    int climbStairs(int n)
    {
	    if (!n || 1 == n)
	    	return 1;
	    int i, n1, n2, res;
	    n1 = n2 = 1;
	    for (i = 2; i <= n; ++i)
	    {
	    	res = n1 + n2;
	    	n1 = n2;
	    	n2 = res;
	    }
	    return res;
    }

### 方法二---迭代

    //迭代的方法
    int climbStairsCore(int n, int *record) {    //climbStairsCore最终都会返回一个或1或2的int值
        if (n == 1) {
            return 1;
        }
        else if (n == 2) {
            return 2;
        }
        else {
            int resultA = *(record + n - 1);    //第一次走一步
            if (resultA == -1) {
                resultA = climbStairsCore(n - 1, record);    //迭代
                *(record + n - 1) = resultA;
            }
            
            int resultB = *(record + n - 2);    //第一次走两步
            if (resultB == -1) {
                resultB = climbStairsCore(n - 2, record);    //迭代
                *(record + n - 2) = resultB;
            }
            return (resultA + resultB);
        }
    }
    
    int climbStairs(int n) {
        int *record = malloc(sizeof(int)*n);
        for (int i = 0; i < n; i++) {
            *(record + i) = -1;
        }
        return climbStairsCore(n, record);
    }

   

## C++实现

    //斐波那契数列方法
    int climbStairs(int n) 
    {
         vector<int> steps(n,0);
         steps[0]=1;
         steps[1]=2;
         for(int i=2;i<n;i++)
         {
             steps[i]=steps[i-2]+steps[i-1];
         }
         return steps[n-1];
    }




